<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="../../../js/vue.js"></script>
	</head>
	<body>
		<div id="root">
			<div>两个重要的小原则:</div>
			<div>1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象</div>
			<div>2.所有不被Vue所管理的函数(定时器的回调函数、ajax的回调函数等) ，最好写成箭头函数,这样this的指向才是vm 或 组件实例对象。</div>
			<div>{{info}}</div>
			<button @click="click">A01_属性的监听</button>
		</div>
		<script>
			var vm = new Vue({
				el: "#root",
				data() {
					return {
						preson: {
							is: "true",
							Boolean: "true"
						}
					}
				},
				// 计算的方法（简单写法）（computed方法有缓存（当依赖发生改变就刷新缓存）methods没有缓存）
				methods: {
					click() {
						this.preson.is = !this.preson.is
					}
				},
				// 计算的方法（简单写法）（computed方法有缓存（当依赖发生改变就刷新缓存）methods没有缓存）
				computed: {
					info() {
						return this.preson.is ? "真" : "假"
					}
				},
				// 监听的对象 (可以实现异步)
				watch: {
					// 要监听的属性名 要监听多层结构属性名
					"preson": {
						// immediate:true,   //初始化的时候调用
						deep: true, //开启深度监听
						// 要监听的属性发现改变就会调用这个 handler方法
						handler(newValue, oldValue) {
							console.log("属性的新值" + newValue.is, "属性的旧值" + oldValue.is)
						}

					}
				},

				//(监听简单的写法)
				// watch: {
				// 	// 要监听多层结构属性名
				// 	"preson.is"(newValue, oldValue) {
				// 		console.log("属性的新值" + newValue, "属性的旧值" + oldValue)
				// 	}
				// },
			})
			// 这个监听的对象(定义外面)  要监听多层结构属性名
			// vm.$watch("preson.is", {
			// 	immediate: true, //初始化的时候调用
			//	deep: true, //开启深度监听
			// 	// 要监听的属性发现改变就会调用这个 handler方法
			// 	handler(newValue, oldValue) {
			// 		console.log("属性的新值" + newValue, "属性的旧值" + oldValue)
			// 	}
			// })
		</script>
	</body>
</html>